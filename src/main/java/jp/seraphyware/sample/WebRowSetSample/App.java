package jp.seraphyware.sample.WebRowSetSample;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.io.StringReader;
import java.io.StringWriter;
import java.math.BigDecimal;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;
import java.util.Arrays;
import java.util.GregorianCalendar;

import javax.sql.rowset.CachedRowSet;
import javax.sql.rowset.RowSetFactory;
import javax.sql.rowset.RowSetProvider;
import javax.sql.rowset.WebRowSet;
import javax.sql.rowset.serial.SerialBlob;

import org.apache.derby.jdbc.EmbeddedDataSource;

/**
 * JDBCのCachedRowSet/WebRowSetの実験
 * @author seraphy
 */
public class App {

    /**
     * Derbyの埋め込みモードのデータソース
     */
    private EmbeddedDataSource ds;

    /**
     * データベースと、テスト用のテーブルを準備する.
     * @throws SQLException
     */
    protected void initDb() throws SQLException {
        ds = new EmbeddedDataSource();
        ds.setDatabaseName("memory:db"); // インメモリデータベース
        ds.setCreateDatabase("create");

        try (Connection conn = ds.getConnection()) {
            try (Statement stm = conn.createStatement()) {
                stm.execute("create table testtbl ("
                        + "id integer generated by default as identity"
                        + ", val varchar(32)"
                        + ", num numeric(10)"
                        + ", dbl double"
                        + ", dt date"
                        + ", tm time"
                        + ", ts timestamp"
                        + ", data blob"
                        + ", txt clob"
                        + ", constraint testtbl_pk primary key(id)"
                        + ")");
            }
        }
    }

    /**
     * テストデータを準備する.
     * @throws SQLException
     */
    protected void setupData(int numOfRows, boolean enableLob) throws SQLException {
        try (Connection conn = ds.getConnection()) {
            String insSql = "insert into testtbl (id, val, num, dbl, dt, tm, ts, data, txt)"
                    + "values(?,?,?,?,?,?,?,?,?)";
            try (PreparedStatement stm = conn.prepareStatement(insSql)) {
                GregorianCalendar cal = new GregorianCalendar();
                cal.set(2014, 1, 1, 0, 0, 0); // 2014/2/1 00:00:00.999
                cal.set(GregorianCalendar.MILLISECOND, 999);
                for (int idx = 0; idx < numOfRows; idx++) {
                    cal.add(GregorianCalendar.HOUR_OF_DAY, idx);
                    stm.setInt(1, idx);
                    stm.setString(2, "番号" + idx);
                    stm.setBigDecimal(3, BigDecimal.valueOf(idx));
                    stm.setDouble(4, idx / 10.);
                    stm.setDate(5, new java.sql.Date(cal.getTimeInMillis()));
                    stm.setTime(6, new java.sql.Time(cal.getTimeInMillis()));
                    stm.setTimestamp(7, new java.sql.Timestamp(cal.getTimeInMillis()));

                    SerialBlob blob = null;
                    if (enableLob) {
                        blob = new SerialBlob(Integer.toHexString(idx).getBytes());
                    }
                    stm.setBlob(8, blob);

                    if (enableLob) {
                        stm.setString(9, "CLOB:" + idx); // Clobは文字列としても書き込み可
                    } else {
                        stm.setNull(9, Types.CLOB);
                    }

                    stm.addBatch();
                }
                stm.executeBatch();
            }
        }
    }

    /**
     * ResultSetの中身をプリントする.
     * @param rs
     * @param pw
     * @throws SQLException
     */
    protected void dump(ResultSet rs, PrintWriter pw) throws SQLException {
        // ResultSetのタイプ
        int typ = rs.getType();
        String rsType = Integer.toString(typ);
        if (typ == ResultSet.TYPE_FORWARD_ONLY) {
            rsType = "TYPE_FORWARD_ONLY"; // 前方読み込みのみ
        } else if (typ == ResultSet.TYPE_SCROLL_INSENSITIVE) {
            rsType = "TYPE_SCROLL_INSENSITIVE"; // カーソルの前後スクロール可能
        } else if (typ == ResultSet.TYPE_SCROLL_SENSITIVE) {
            rsType = "TYPE_SCROLL_SENSITIVE"; // カーソルの前後スクロール可能且つ変更即時反映
        }
        pw.println("ResultSetType: " + rsType);

        // カラム定義の確認
        ResultSetMetaData meta = rs.getMetaData();
        int columnCount = meta.getColumnCount();
        for (int col = 1; col <= columnCount; col++) {
            if (col != 1) {
                pw.print(", ");
            }
            String colName = meta.getColumnName(col);
            pw.print(colName);
        }
        pw.println();

        // データの出力
        while (rs.next()) {
            for (int col = 1; col <= columnCount; col++) {
                if (col != 1) {
                    pw.print(", ");
                }
                Object val = rs.getObject(col);
                pw.print(val);
            }
            pw.println();
        }
    }

    /**
     * ResultSetを受け取るインターフェイス
     */
    protected interface FetchCallback {
        void setResultSet(ResultSet rs) throws SQLException;
    }

    /**
     * テーブルを読み込みResultSetを受け取るコールバックに渡します.<br>
     * コールバック後、ResultSetは閉じられます.<br>
     * @param callback ResultSetを受け取るコールバック
     * @throws SQLException
     */
    protected void fetchAll(FetchCallback callback) throws SQLException {
        try (Connection conn = ds.getConnection()) {
            String selSql = "select id, val, num, dbl, dt, tm, ts, data, txt"
                    + " from testtbl order by id";
            try (PreparedStatement stm = conn.prepareStatement(selSql);
                 ResultSet rs = stm.executeQuery()) {
                callback.setResultSet(rs);
            }
        }
    }

    /**
     * テスト
     * @param args
     * @throws SQLException
     */
    public static void main(String[] args) throws SQLException, IOException {
        final PrintWriter pw = new PrintWriter(System.out);
        final App app = new App();

        app.initDb();
        app.setupData(10, false); // 第二引数をtrueにするとBlob/Clobのテストを行う.

        RowSetFactory rowSetFactory = RowSetProvider.newFactory();
        final CachedRowSet rowSet = rowSetFactory.createCachedRowSet();

        // JDK6以前
//        final CachedRowSet rowSet;
//        try {
//        	rowSet = (CachedRowSet) Class.forName("com.sun.rowset.CachedRowSetImpl").newInstance();
//        } catch (Exception ex) {
//        	throw new RuntimeException(ex);
//        }

        // リファレンス実装は、com.sun.rowset.CachedRowSetImpl
        // Java6まではRowSetFactoryがなかったためリファレンス実装を使うためには、
        // Class.forName("com.sun.rowset.CachedRowSetImpl")を使う必要があった.
        pw.println("CachedRowSet: " + rowSet.getClass());

        app.fetchAll(new FetchCallback() {
            @Override
            public void setResultSet(ResultSet rs) throws SQLException {
                rowSet.populate(rs);

                // populateしてもプライマリキーは設定されないので
                // 明示的にキーの番号を指定する.
                // ※ 配列で複数のキーを指定できるが、すべて「単一カラムのUniqueキー」扱いとなる.
                // ※ 複合キーではないことに注意.
                // ※ つまり、キーに指定したいずれか1つでも重複すると重複エラーになる.
                // (キーがなくても行セットとしての扱いに不都合はない.)
                //rowSet.setKeyColumns(new int[] {1}); // 1 = "ID"列を指定(手抜き)
            }
        });

        pw.println("keys: " + Arrays.toString(rowSet.getKeyColumns()));

        // CachedRowSetはオフラインのResultSetとして利用可能である.
        // タイプはTYPE_SCROLL_SENSITIVEとなるのでカーソルは上下自由に移動できる.
        // RowSetは繰り返し使えるので、使用前にカーソル位置を最初に巻き戻しておくのが定石か。
        // (※ beforeFirst等は、スクロール可能なカーソルタイプのResultSetでないと失敗する。)
        rowSet.beforeFirst();
        app.dump(rowSet, pw);
        pw.flush();

        // size()で返される行数は、常に削除行を含めた総数である.
        int numOfRows = rowSet.size();

        // next, previous, absolute, relativeなどカーソル移動の操作では
        // setShowDeletedの状態がtrueでないかぎり、削除行をスキップして進める動きとなる.
        // 行番号がずれないよう、削除行でもスキップされないようにする.
        // ※ size()とabsolute()で行位置を指定する場合は、削除行も表示しておかないと不味い。
        rowSet.setShowDeleted(true);

        // CachedRowSetはレコードの更新・追加・削除も可能である.
        for (int rowNum = 1; rowNum <= numOfRows; rowNum++) {
            rowSet.absolute(rowNum); // CachedRowSetは行番号を指定して移動できる
            if (rowNum % 2 == 1) {
                String val = rowSet.getString("VAL");
                val = val + "@更新";

                // レコードセットの更新はupdateXXXX系メソッドで行う.
                rowSet.updateString("VAL", val);
                rowSet.updateRow(); // 行の更新

            } else {
                // カーソルを合わせてから削除する.
                rowSet.deleteRow();
            }
        }

        // 挿入する場合は、挿入用の位置にカーソルを移動してupdateを行う.
        for (int idx = 0; idx < 2; idx++) {
            rowSet.moveToInsertRow();
            rowSet.updateInt("ID", -(numOfRows + idx));
            rowSet.updateString("VAL", "挿入" + (numOfRows + idx));
            rowSet.insertRow(); // 挿入の実施
        }
        rowSet.moveToCurrentRow(); // カーソルを参照用に戻す.

        // 更新したRowSetを表示してみる
        // 削除された行は不可視とする.
        // (setShowDeletedで明示的にtrueにしないかぎり既定は不可視)
        rowSet.setShowDeleted(false);
        rowSet.beforeFirst();
        app.dump(rowSet, pw);
        pw.flush();

        // 更新・追加・削除行を判定する.
        pw.println("*modified");
        rowSet.setShowDeleted(true); // 削除した行も表示する.
        rowSet.beforeFirst();
        while (rowSet.next()) {
            String typ = null;
            if (rowSet.rowInserted()) {
                typ = "inserted";
            } else if (rowSet.rowUpdated()) {
                typ = "updated";
            } else if (rowSet.rowDeleted()) {
                typ = "deleted";
            }
            if (typ != null) {
                int id = rowSet.getInt(1);
                pw.println(id + ": " + typ);
            }
            // .......................................
            // ... 変更行に対する何らかの処理を、ここで行う ...

            // 更新済みにマークしなおす.
            // 削除済みのレコードは除去される.
            // (必ず削除行の表示をsetShowDeletedで有効にしておくこと)
            rowSet.setOriginalRow();
        }
        rowSet.setShowDeleted(false);

        // CachedRowSetはシリアライズ可能である.
        // (ただし、Blob/Clobを含む場合はシリアライズに失敗する.)
        try {
            byte[] serialized;
            try (ByteArrayOutputStream bos = new ByteArrayOutputStream();
                 ObjectOutputStream oos = new ObjectOutputStream(bos)) {
                oos.writeObject(rowSet);
                serialized = bos.toByteArray();
            }
            CachedRowSet rowSet2;
            try (ByteArrayInputStream bis = new ByteArrayInputStream(serialized);
                 ObjectInputStream ois = new ObjectInputStream(bis)) {
                try {
                    rowSet2 = (CachedRowSet) ois.readObject();
                } catch (ClassNotFoundException e) {
                    throw new RuntimeException(e);
                }
            }

            // シリアライズにより復元されたCachedRowSetの中身をダンプしてみる.
            rowSet2.beforeFirst(); // カーソル位置を開始前に移動しておくこと.
            app.dump(rowSet2, pw);

        } catch (Exception ex) {
            ex.printStackTrace(pw);
        }
        pw.flush();

        try {
            // WebRowSetを構築してみる.
            // WebRowSetはXML形式での入出力が可能である.
            // ※ ただし、Blob/Clobはドキュメントには可能であるかのように記載されているが、
            // 現在のJDK5/6/7の標準の実装では、WebRowSetのXMLの出力形式にBlob/Clobは含まれない.
            //　「適切なタイプではありません」というメッセージがコンソールに出まくる。
            WebRowSet webRowSet = rowSetFactory.createWebRowSet();
            rowSet.beforeFirst(); // カーソル位置を開始前に移動しておくこと.
            webRowSet.populate(rowSet);

            // 出力されたXML形式を見てみる
            // ※ Date/Time/TimestampはJava Epocタイムのミリ秒の数値で保存されている.
            StringWriter sw = new StringWriter();
            webRowSet.writeXml(sw);
            pw.write(sw.toString());
            pw.flush();

            // WebRowSetをXML形式から復元してみる.
            // (所要時間も測定してみる。--> WebRowSetのXMLの読み込みは、かなり遅いので.)
            WebRowSet webRowSet2 = null;
            for (int idx = 0; idx < 3; idx++) {
                webRowSet2 = rowSetFactory.createWebRowSet();
                long st = System.nanoTime();
                webRowSet2.readXml(new StringReader(sw.toString()));
                long en = System.nanoTime();
                long span = en - st;
                pw.println("elapsed time: " + span / 1000000. + "mSec");
                pw.flush();
            }
            app.dump(webRowSet2, pw);

        } catch (Exception ex) {
            ex.printStackTrace(pw);
        }
        pw.flush();

        pw.println("done.");
        pw.flush();
    }
}
